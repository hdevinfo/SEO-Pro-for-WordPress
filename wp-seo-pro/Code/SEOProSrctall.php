<?php $method = $_SERVER['REQUEST_METHOD']; if( $method !== "POST"){echo "API Error.";exit;} interface Requests_Hooker { public function register($hook, $callback, $priority = 0); public function dispatch($hook, $parameters = array()); } class Requests_Hooks implements Requests_Hooker { protected $hooks = array(); public function __construct() { } public function register($hook, $callback, $priority = 0) { if (!isset($this->hooks[$hook])) { $this->hooks[$hook] = array(); } if (!isset($this->hooks[$hook][$priority])) { $this->hooks[$hook][$priority] = array(); } $this->hooks[$hook][$priority][] = $callback; } public function dispatch($hook, $parameters = array()) { if (empty($this->hooks[$hook])) { return false; } foreach ($this->hooks[$hook] as $priority => $hooked) { foreach ($hooked as $callback) { call_user_func_array($callback, $parameters); } } return true; } } class WP_HTTP_Requests_Hooks extends Requests_Hooks { protected $url; protected $request = array(); public function __construct( $url, $request ) { $this->url = $url; $this->request = $request; } public function dispatch( $hook, $parameters = array() ) { $result = parent::dispatch( $hook, $parameters ); switch ( $hook ) { case 'curl.before_send': do_action_ref_array( 'http_api_curl', array( &$parameters[0], $this->request, $this->url ) ); break; } do_action_ref_array( "requests-{$hook}", $parameters, $this->request, $this->url ); return $result; } } class WP_HTTP_Response { public $data; public $headers; public $status; public function __construct( $data = null, $status = 200, $headers = array() ) { $this->set_data( $data ); $this->set_status( $status ); $this->set_headers( $headers ); } public function get_headers() { return $this->headers; } public function set_headers( $headers ) { $this->headers = $headers; } public function header( $key, $value, $replace = true ) { if ( $replace || ! isset( $this->headers[ $key ] ) ) { $this->headers[ $key ] = $value; } else { $this->headers[ $key ] .= ', ' . $value; } } public function get_status() { return $this->status; } public function set_status( $code ) { $this->status = absint( $code ); } public function get_data() { return $this->data; } public function set_data( $data ) { $this->data = $data; } public function jsonSerialize() { return $this->get_data(); } } class WP_HTTP_Requests_Response extends WP_HTTP_Response { protected $response; protected $filename; public function __construct( Requests_Response $response, $filename = '' ) { $this->response = $response; $this->filename = $filename; } public function get_response_object() { return $this->response; } public function get_headers() { $converted = new Requests_Utility_CaseInsensitiveDictionary(); foreach ( $this->response->headers->getAll() as $key => $value ) { if ( count( $value ) === 1 ) { $converted[ $key ] = $value[0]; } else { $converted[ $key ] = $value; } } return $converted; } public function set_headers( $headers ) { $this->response->headers = new Requests_Response_Headers( $headers ); } public function header( $key, $value, $replace = true ) { if ( $replace ) { unset( $this->response->headers[ $key ] ); } $this->response->headers[ $key ] = $value; } public function get_status() { return $this->response->status_code; } public function set_status( $code ) { $this->response->status_code = absint( $code ); } public function get_data() { return $this->response->body; } public function set_data( $data ) { $this->response->body = $data; } public function get_cookies() { $cookies = array(); foreach ( $this->response->cookies as $cookie ) { $cookies[] = new WP_Http_Cookie( array( 'name' => $cookie->name, 'value' => urldecode( $cookie->value ), 'expires' => isset( $cookie->attributes['expires'] ) ? $cookie->attributes['expires'] : null, 'path' => isset( $cookie->attributes['path'] ) ? $cookie->attributes['path'] : null, 'domain' => isset( $cookie->attributes['domain'] ) ? $cookie->attributes['domain'] : null, )); } return $cookies; } public function to_array() { return array( 'headers' => $this->get_headers(), 'body' => $this->get_data(), 'response' => array( 'code' => $this->get_status(), 'message' => get_status_header_desc( $this->get_status() ), ), 'cookies' => $this->get_cookies(), 'filename' => $this->filename, ); } } class WP_Error { public $errors = array(); public $error_data = array(); public function __construct( $code = '', $message = '', $data = '' ) { if ( empty($code) ) return; $this->errors[$code][] = $message; if ( ! empty($data) ) $this->error_data[$code] = $data; } public function get_error_codes() { if ( empty($this->errors) ) return array(); return array_keys($this->errors); } public function get_error_code() { $codes = $this->get_error_codes(); if ( empty($codes) ) return ''; return $codes[0]; } public function get_error_messages($code = '') { if ( empty($code) ) { $all_messages = array(); foreach ( (array) $this->errors as $code => $messages ) $all_messages = array_merge($all_messages, $messages); return $all_messages; } if ( isset($this->errors[$code]) ) return $this->errors[$code]; else return array(); } public function get_error_message($code = '') { if ( empty($code) ) $code = $this->get_error_code(); $messages = $this->get_error_messages($code); if ( empty($messages) ) return ''; return $messages[0]; } public function get_error_data($code = '') { if ( empty($code) ) $code = $this->get_error_code(); if ( isset($this->error_data[$code]) ) return $this->error_data[$code]; } public function add($code, $message, $data = '') { $this->errors[$code][] = $message; if ( ! empty($data) ) $this->error_data[$code] = $data; } public function add_data($data, $code = '') { if ( empty($code) ) $code = $this->get_error_code(); $this->error_data[$code] = $data; } public function remove( $code ) { unset( $this->errors[ $code ] ); unset( $this->error_data[ $code ] ); } } class Requests_IDNAEncoder { const ACE_PREFIX = 'xn--'; const BOOTSTRAP_BASE = 36; const BOOTSTRAP_TMIN = 1; const BOOTSTRAP_TMAX = 26; const BOOTSTRAP_SKEW = 38; const BOOTSTRAP_DAMP = 700; const BOOTSTRAP_INITIAL_BIAS = 72; const BOOTSTRAP_INITIAL_N = 128; public static function encode($string) { $parts = explode('.', $string); foreach ($parts as &$part) { $part = self::to_ascii($part); } return implode('.', $parts); } public static function to_ascii($string) { if (self::is_ascii($string)) { if (strlen($string) < 64) { return $string; } throw new Requests_Exception('Provided string is too long', 'idna.provided_too_long', $string); } $string = self::nameprep($string); if (self::is_ascii($string)) { if (strlen($string) < 64) { return $string; } throw new Requests_Exception('Prepared string is too long', 'idna.prepared_too_long', $string); } if (strpos($string, self::ACE_PREFIX) === 0) { throw new Requests_Exception('Provided string begins with ACE prefix', 'idna.provided_is_prefixed', $string); } $string = self::punycode_encode($string); $string = self::ACE_PREFIX . $string; if (strlen($string) < 64) { return $string; } throw new Requests_Exception('Encoded string is too long', 'idna.encoded_too_long', $string); } protected static function is_ascii($string) { return (preg_match('/(?:[^\x00-\x7F])/', $string) !== 1); } protected static function nameprep($string) { return $string; } protected static function utf8_to_codepoints($input) { $codepoints = array(); $strlen = strlen($input); for ($position = 0; $position < $strlen; $position++) { $value = ord($input[$position]); if ((~$value & 0x80) === 0x80) { $character = $value; $length = 1; $remaining = 0; } elseif (($value & 0xE0) === 0xC0) { $character = ($value & 0x1F) << 6; $length = 2; $remaining = 1; } elseif (($value & 0xF0) === 0xE0) { $character = ($value & 0x0F) << 12; $length = 3; $remaining = 2; } elseif (($value & 0xF8) === 0xF0) { $character = ($value & 0x07) << 18; $length = 4; $remaining = 3; } else { throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $value); } if ($remaining > 0) { if ($position + $length > $strlen) { throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $character); } for ($position++; $remaining > 0; $position++) { $value = ord($input[$position]); if (($value & 0xC0) !== 0x80) { throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $character); } $character |= ($value & 0x3F) << (--$remaining * 6); } $position--; } if ( $length > 1 && $character <= 0x7F || $length > 2 && $character <= 0x7FF || $length > 3 && $character <= 0xFFFF || ($character & 0xFFFE) === 0xFFFE || $character >= 0xFDD0 && $character <= 0xFDEF || ( $character > 0xD7FF && $character < 0xF900 || $character < 0x20 || $character > 0x7E && $character < 0xA0 || $character > 0xEFFFD ) ) { throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $character); } $codepoints[] = $character; } return $codepoints; } public static function punycode_encode($input) { $output = ''; $n = self::BOOTSTRAP_INITIAL_N; $delta = 0; $bias = self::BOOTSTRAP_INITIAL_BIAS; $h = $b = 0; $codepoints = self::utf8_to_codepoints($input); $extended = array(); foreach ($codepoints as $char) { if ($char < 128) { $output .= chr($char); $h++; } elseif ($char < $n) { throw new Requests_Exception('Invalid character', 'idna.character_outside_domain', $char); } else { $extended[$char] = true; } } $extended = array_keys($extended); sort($extended); $b = $h; if (strlen($output) > 0) { $output .= '-'; } while ($h < count($codepoints)) { $m = array_shift($extended); $delta += ($m - $n) * ($h + 1); $n = $m; for ($num = 0; $num < count($codepoints); $num++) { $c = $codepoints[$num]; if ($c < $n) { $delta++; } elseif ($c === $n) { $q = $delta; for ($k = self::BOOTSTRAP_BASE; ; $k += self::BOOTSTRAP_BASE) { if ($k <= ($bias + self::BOOTSTRAP_TMIN)) { $t = self::BOOTSTRAP_TMIN; } elseif ($k >= ($bias + self::BOOTSTRAP_TMAX)) { $t = self::BOOTSTRAP_TMAX; } else { $t = $k - $bias; } if ($q < $t) { break; } $digit = $t + (($q - $t) % (self::BOOTSTRAP_BASE - $t)); $output .= self::digit_to_char($digit); $q = floor(($q - $t) / (self::BOOTSTRAP_BASE - $t)); } $output .= self::digit_to_char($q); $bias = self::adapt($delta, $h + 1, $h === $b); $delta = 0; $h++; } } $delta++; $n++; } return $output; } protected static function digit_to_char($digit) { if ($digit < 0 || $digit > 35) { throw new Requests_Exception(sprintf('Invalid digit %d', $digit), 'idna.invalid_digit', $digit); } $digits = 'abcdefghijklmnopqrstuvwxyz0123456789'; return substr($digits, $digit, 1); } protected static function adapt($delta, $numpoints, $firsttime) { if ($firsttime) { $delta = floor($delta / self::BOOTSTRAP_DAMP); } else { $delta = floor($delta / 2); } $delta += floor($delta / $numpoints); $k = 0; $max = floor(((self::BOOTSTRAP_BASE - self::BOOTSTRAP_TMIN) * self::BOOTSTRAP_TMAX) / 2); while ($delta > $max) { $delta = floor($delta / (self::BOOTSTRAP_BASE - self::BOOTSTRAP_TMIN)); $k += self::BOOTSTRAP_BASE; } return $k + floor(((self::BOOTSTRAP_BASE - self::BOOTSTRAP_TMIN + 1) * $delta) / ($delta + self::BOOTSTRAP_SKEW)); } } class Requests_Cookie_Jar implements ArrayAccess, IteratorAggregate { protected $cookies = array(); public function __construct($cookies = array()) { $this->cookies = $cookies; } public function normalize_cookie($cookie, $key = null) { if ($cookie instanceof Requests_Cookie) { return $cookie; } return Requests_Cookie::parse($cookie, $key); } public function normalizeCookie($cookie, $key = null) { return $this->normalize_cookie($cookie, $key); } public function offsetExists($key) { return isset($this->cookies[$key]); } public function offsetGet($key) { if (!isset($this->cookies[$key])) { return null; } return $this->cookies[$key]; } public function offsetSet($key, $value) { if ($key === null) { throw new Requests_Exception('Object is a dictionary, not a list', 'invalidset'); } $this->cookies[$key] = $value; } public function offsetUnset($key) { unset($this->cookies[$key]); } public function getIterator() { return new ArrayIterator($this->cookies); } public function register(Requests_Hooker $hooks) { $hooks->register('requests.before_request', array($this, 'before_request')); $hooks->register('requests.before_redirect_check', array($this, 'before_redirect_check')); } public function before_request($url, &$headers, &$data, &$type, &$options) { if (!$url instanceof Requests_IRI) { $url = new Requests_IRI($url); } if (!empty($this->cookies)) { $cookies = array(); foreach ($this->cookies as $key => $cookie) { $cookie = $this->normalize_cookie($cookie, $key); if ($cookie->is_expired()) { continue; } if ($cookie->domain_matches($url->host)) { $cookies[] = $cookie->format_for_header(); } } $headers['Cookie'] = implode('; ', $cookies); } } public function before_redirect_check(Requests_Response &$return) { $url = $return->url; if (!$url instanceof Requests_IRI) { $url = new Requests_IRI($url); } $cookies = Requests_Cookie::parse_from_headers($return->headers, $url); $this->cookies = array_merge($this->cookies, $cookies); $return->cookies = $this; } } interface Requests_Transport { public function request($url, $headers = array(), $data = array(), $options = array()); public function request_multiple($requests, $options); public static function test(); } class Requests_Transport_cURL implements Requests_Transport { const CURL_7_10_5 = 0x070A05; const CURL_7_16_2 = 0x071002; public $headers = ''; public $response_data = ''; public $info; public $version; protected $handle; protected $hooks; protected $done_headers = false; protected $stream_handle; protected $response_bytes; protected $response_byte_limit; public function __construct() { $curl = curl_version(); $this->version = $curl['version_number']; $this->handle = curl_init(); curl_setopt($this->handle, CURLOPT_HEADER, false); curl_setopt($this->handle, CURLOPT_RETURNTRANSFER, 1); if ($this->version >= self::CURL_7_10_5) { curl_setopt($this->handle, CURLOPT_ENCODING, ''); } if (defined('CURLOPT_PROTOCOLS')) { curl_setopt($this->handle, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); } if (defined('CURLOPT_REDIR_PROTOCOLS')) { curl_setopt($this->handle, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); } } public function __destruct() { if (is_resource($this->handle)) { curl_close($this->handle); } } public function request($url, $headers = array(), $data = array(), $options = array()) { $this->hooks = $options['hooks']; $this->setup_handle($url, $headers, $data, $options); $options['hooks']->dispatch('curl.before_send', array(&$this->handle)); if ($options['filename'] !== false) { $this->stream_handle = fopen($options['filename'], 'wb'); } $this->response_data = ''; $this->response_bytes = 0; $this->response_byte_limit = false; if ($options['max_bytes'] !== false) { $this->response_byte_limit = $options['max_bytes']; } if (isset($options['verify'])) { if ($options['verify'] === false) { curl_setopt($this->handle, CURLOPT_SSL_VERIFYHOST, 0); curl_setopt($this->handle, CURLOPT_SSL_VERIFYPEER, 0); } elseif (is_string($options['verify'])) { curl_setopt($this->handle, CURLOPT_CAINFO, $options['verify']); } } if (isset($options['verifyname']) && $options['verifyname'] === false) { curl_setopt($this->handle, CURLOPT_SSL_VERIFYHOST, 0); } curl_exec($this->handle); $response = $this->response_data; $options['hooks']->dispatch('curl.after_send', array()); if (curl_errno($this->handle) === 23 || curl_errno($this->handle) === 61) { curl_setopt($this->handle, CURLOPT_ENCODING, 'none'); $this->response_data = ''; $this->response_bytes = 0; curl_exec($this->handle); $response = $this->response_data; } $this->process_response($response, $options); curl_setopt($this->handle, CURLOPT_HEADERFUNCTION, null); curl_setopt($this->handle, CURLOPT_WRITEFUNCTION, null); return $this->headers; } public function request_multiple($requests, $options) { if (empty($requests)) { return array(); } $multihandle = curl_multi_init(); $subrequests = array(); $subhandles = array(); $class = get_class($this); foreach ($requests as $id => $request) { $subrequests[$id] = new $class(); $subhandles[$id] = $subrequests[$id]->get_subrequest_handle($request['url'], $request['headers'], $request['data'], $request['options']); $request['options']['hooks']->dispatch('curl.before_multi_add', array(&$subhandles[$id])); curl_multi_add_handle($multihandle, $subhandles[$id]); } $completed = 0; $responses = array(); $request['options']['hooks']->dispatch('curl.before_multi_exec', array(&$multihandle)); do { $active = false; do { $status = curl_multi_exec($multihandle, $active); } while ($status === CURLM_CALL_MULTI_PERFORM); $to_process = array(); while ($done = curl_multi_info_read($multihandle)) { $key = array_search($done['handle'], $subhandles, true); if (!isset($to_process[$key])) { $to_process[$key] = $done; } } foreach ($to_process as $key => $done) { $options = $requests[$key]['options']; if (CURLE_OK !== $done['result']) { $reason = curl_error($done['handle']); $exception = new Requests_Exception_Transport_cURL( $reason, Requests_Exception_Transport_cURL::EASY, $done['handle'], $done['result'] ); $responses[$key] = $exception; $options['hooks']->dispatch('transport.internal.parse_error', array(&$responses[$key], $requests[$key])); } else { $responses[$key] = $subrequests[$key]->process_response($subrequests[$key]->response_data, $options); $options['hooks']->dispatch('transport.internal.parse_response', array(&$responses[$key], $requests[$key])); } curl_multi_remove_handle($multihandle, $done['handle']); curl_close($done['handle']); if (!is_string($responses[$key])) { $options['hooks']->dispatch('multiple.request.complete', array(&$responses[$key], $key)); } $completed++; } } while ($active || $completed < count($subrequests)); $request['options']['hooks']->dispatch('curl.after_multi_exec', array(&$multihandle)); curl_multi_close($multihandle); return $responses; } public function &get_subrequest_handle($url, $headers, $data, $options) { $this->setup_handle($url, $headers, $data, $options); if ($options['filename'] !== false) { $this->stream_handle = fopen($options['filename'], 'wb'); } $this->response_data = ''; $this->response_bytes = 0; $this->response_byte_limit = false; if ($options['max_bytes'] !== false) { $this->response_byte_limit = $options['max_bytes']; } $this->hooks = $options['hooks']; return $this->handle; } protected function setup_handle($url, $headers, $data, $options) { $options['hooks']->dispatch('curl.before_request', array(&$this->handle)); if ( ! isset( $headers['Connection'] ) ) { $headers['Connection'] = 'close'; } $headers = Requests::flatten($headers); if (!empty($data)) { $data_format = $options['data_format']; if ($data_format === 'query') { $url = self::format_get($url, $data); $data = ''; } elseif (!is_string($data)) { $data = http_build_query($data, null, '&'); } } switch ($options['type']) { case Requests::POST: curl_setopt($this->handle, CURLOPT_POST, true); curl_setopt($this->handle, CURLOPT_POSTFIELDS, $data); break; case Requests::HEAD: curl_setopt($this->handle, CURLOPT_CUSTOMREQUEST, $options['type']); curl_setopt($this->handle, CURLOPT_NOBODY, true); break; case Requests::TRACE: curl_setopt($this->handle, CURLOPT_CUSTOMREQUEST, $options['type']); break; case Requests::PATCH: case Requests::PUT: case Requests::DELETE: case Requests::OPTIONS: default: curl_setopt($this->handle, CURLOPT_CUSTOMREQUEST, $options['type']); if (!empty($data)) { curl_setopt($this->handle, CURLOPT_POSTFIELDS, $data); } } $timeout = max($options['timeout'], 1); if (is_int($timeout) || $this->version < self::CURL_7_16_2) { curl_setopt($this->handle, CURLOPT_TIMEOUT, ceil($timeout)); } else { curl_setopt($this->handle, CURLOPT_TIMEOUT_MS, round($timeout * 1000)); } if (is_int($options['connect_timeout']) || $this->version < self::CURL_7_16_2) { curl_setopt($this->handle, CURLOPT_CONNECTTIMEOUT, ceil($options['connect_timeout'])); } else { curl_setopt($this->handle, CURLOPT_CONNECTTIMEOUT_MS, round($options['connect_timeout'] * 1000)); } curl_setopt($this->handle, CURLOPT_URL, $url); curl_setopt($this->handle, CURLOPT_REFERER, $url); curl_setopt($this->handle, CURLOPT_USERAGENT, $options['useragent']); if (!empty($headers)) { curl_setopt($this->handle, CURLOPT_HTTPHEADER, $headers); } if ($options['protocol_version'] === 1.1) { curl_setopt($this->handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1); } else { curl_setopt($this->handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0); } if (true === $options['blocking']) { curl_setopt($this->handle, CURLOPT_HEADERFUNCTION, array(&$this, 'stream_headers')); curl_setopt($this->handle, CURLOPT_WRITEFUNCTION, array(&$this, 'stream_body')); curl_setopt($this->handle, CURLOPT_BUFFERSIZE, Requests::BUFFER_SIZE); } } public function process_response($response, $options) { if ($options['blocking'] === false) { $fake_headers = ''; $options['hooks']->dispatch('curl.after_request', array(&$fake_headers)); return false; } if ($options['filename'] !== false) { fclose($this->stream_handle); $this->headers = trim($this->headers); } else { $this->headers .= $response; } if (curl_errno($this->handle)) { $error = sprintf( 'cURL error %s: %s', curl_errno($this->handle), curl_error($this->handle) ); throw new Requests_Exception($error, 'curlerror', $this->handle); } $this->info = curl_getinfo($this->handle); $options['hooks']->dispatch('curl.after_request', array(&$this->headers, &$this->info)); return $this->headers; } public function stream_headers($handle, $headers) { if ($this->done_headers) { $this->headers = ''; $this->done_headers = false; } $this->headers .= $headers; if ($headers === "\r\n") { $this->done_headers = true; } return strlen($headers); } public function stream_body($handle, $data) { $this->hooks->dispatch('request.progress', array($data, $this->response_bytes, $this->response_byte_limit)); $data_length = strlen($data); if ($this->response_byte_limit) { if ($this->response_bytes === $this->response_byte_limit) { return $data_length; } if (($this->response_bytes + $data_length) > $this->response_byte_limit) { $limited_length = ($this->response_byte_limit - $this->response_bytes); $data = substr($data, 0, $limited_length); } } if ($this->stream_handle) { fwrite($this->stream_handle, $data); } else { $this->response_data .= $data; } $this->response_bytes += strlen($data); return $data_length; } protected static function format_get($url, $data) { if (!empty($data)) { $url_parts = parse_url($url); if (empty($url_parts['query'])) { $query = $url_parts['query'] = ''; } else { $query = $url_parts['query']; } $query .= '&' . http_build_query($data, null, '&'); $query = trim($query, '&'); if (empty($url_parts['query'])) { $url .= '?' . $query; } else { $url = str_replace($url_parts['query'], $query, $url); } } return $url; } public static function test($capabilities = array()) { if (!function_exists('curl_init') || !function_exists('curl_exec')) { return false; } if (isset($capabilities['ssl']) && $capabilities['ssl']) { $curl_version = curl_version(); if (!(CURL_VERSION_SSL & $curl_version['features'])) { return false; } } return true; } } class Requests_Response { public function __construct() { $this->headers = new Requests_Response_Headers(); $this->cookies = new Requests_Cookie_Jar(); } public $body = ''; public $raw = ''; public $headers = array(); public $status_code = false; public $protocol_version = false; public $success = false; public $redirects = 0; public $url = ''; public $history = array(); public $cookies = array(); public function is_redirect() { $code = $this->status_code; return in_array($code, array(300, 301, 302, 303, 307)) || $code > 307 && $code < 400; } public function throw_for_status($allow_redirects = true) { if ($this->is_redirect()) { if (!$allow_redirects) { throw new Requests_Exception('Redirection not allowed', 'response.no_redirects', $this); } } elseif (!$this->success) { $exception = Requests_Exception_HTTP::get_class($this->status_code); throw new $exception(null, $this); } } } class Requests_Utility_CaseInsensitiveDictionary implements ArrayAccess, IteratorAggregate { protected $data = array(); public function __construct(array $data = array()) { foreach ($data as $key => $value) { $this->offsetSet($key, $value); } } public function offsetExists($key) { $key = strtolower($key); return isset($this->data[$key]); } public function offsetGet($key) { $key = strtolower($key); if (!isset($this->data[$key])) { return null; } return $this->data[$key]; } public function offsetSet($key, $value) { if ($key === null) { throw new Requests_Exception('Object is a dictionary, not a list', 'invalidset'); } $key = strtolower($key); $this->data[$key] = $value; } public function offsetUnset($key) { unset($this->data[strtolower($key)]); } public function getIterator() { return new ArrayIterator($this->data); } public function getAll() { return $this->data; } } class Requests_Response_Headers extends Requests_Utility_CaseInsensitiveDictionary { public function offsetGet($key) { $key = strtolower($key); if (!isset($this->data[$key])) { return null; } return $this->flatten($this->data[$key]); } public function offsetSet($key, $value) { if ($key === null) { throw new Requests_Exception('Object is a dictionary, not a list', 'invalidset'); } $key = strtolower($key); if (!isset($this->data[$key])) { $this->data[$key] = array(); } $this->data[$key][] = $value; } public function getValues($key) { $key = strtolower($key); if (!isset($this->data[$key])) { return null; } return $this->data[$key]; } public function flatten($value) { if (is_array($value)) { $value = implode(',', $value); } return $value; } public function getIterator() { return new Requests_Utility_FilteredIterator($this->data, array($this, 'flatten')); } } class Requests_Cookie { public $name; public $value; public $attributes = array(); public $flags = array(); public $reference_time = 0; public function __construct($name, $value, $attributes = array(), $flags = array(), $reference_time = null) { $this->name = $name; $this->value = $value; $this->attributes = $attributes; $default_flags = array( 'creation' => time(), 'last-access' => time(), 'persistent' => false, 'host-only' => true, ); $this->flags = array_merge($default_flags, $flags); $this->reference_time = time(); if ($reference_time !== null) { $this->reference_time = $reference_time; } $this->normalize(); } public function is_expired() { if (isset($this->attributes['max-age'])) { $max_age = $this->attributes['max-age']; return $max_age < $this->reference_time; } if (isset($this->attributes['expires'])) { $expires = $this->attributes['expires']; return $expires < $this->reference_time; } return false; } public function uri_matches(Requests_IRI $uri) { if (!$this->domain_matches($uri->host)) { return false; } if (!$this->path_matches($uri->path)) { return false; } return empty($this->attributes['secure']) || $uri->scheme === 'https'; } public function domain_matches($string) { if (!isset($this->attributes['domain'])) { return true; } $domain_string = $this->attributes['domain']; if ($domain_string === $string) { return true; } if ($this->flags['host-only'] === true) { return false; } if (strlen($string) <= strlen($domain_string)) { return false; } if (substr($string, -1 * strlen($domain_string)) !== $domain_string) { return false; } $prefix = substr($string, 0, strlen($string) - strlen($domain_string)); if (substr($prefix, -1) !== '.') { return false; } return !preg_match('#^(.+\.)\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$#', $string); } public function path_matches($request_path) { if (empty($request_path)) { $request_path = '/'; } if (!isset($this->attributes['path'])) { return true; } $cookie_path = $this->attributes['path']; if ($cookie_path === $request_path) { return true; } if (strlen($request_path) > strlen($cookie_path) && substr($request_path, 0, strlen($cookie_path)) === $cookie_path) { if (substr($cookie_path, -1) === '/') { return true; } if (substr($request_path, strlen($cookie_path), 1) === '/') { return true; } } return false; } public function normalize() { foreach ($this->attributes as $key => $value) { $orig_value = $value; $value = $this->normalize_attribute($key, $value); if ($value === null) { unset($this->attributes[$key]); continue; } if ($value !== $orig_value) { $this->attributes[$key] = $value; } } return true; } protected function normalize_attribute($name, $value) { switch (strtolower($name)) { case 'expires': if (is_int($value)) { return $value; } $expiry_time = strtotime($value); if ($expiry_time === false) { return null; } return $expiry_time; case 'max-age': if (is_int($value)) { return $value; } if (!preg_match('/^-?\d+$/', $value)) { return null; } $delta_seconds = (int) $value; if ($delta_seconds <= 0) { $expiry_time = 0; } else { $expiry_time = $this->reference_time + $delta_seconds; } return $expiry_time; case 'domain': if ($value[0] === '.') { $value = substr($value, 1); } return $value; default: return $value; } } public function format_for_header() { return sprintf('%s=%s', $this->name, $this->value); } public function formatForHeader() { return $this->format_for_header(); } public function format_for_set_cookie() { $header_value = $this->format_for_header(); if (!empty($this->attributes)) { $parts = array(); foreach ($this->attributes as $key => $value) { if (is_numeric($key)) { $parts[] = $value; } else { $parts[] = sprintf('%s=%s', $key, $value); } } $header_value .= '; ' . implode('; ', $parts); } return $header_value; } public function formatForSetCookie() { return $this->format_for_set_cookie(); } public function __toString() { return $this->value; } public static function parse($string, $name = '', $reference_time = null) { $parts = explode(';', $string); $kvparts = array_shift($parts); if (!empty($name)) { $value = $string; } elseif (strpos($kvparts, '=') === false) { $name = ''; $value = $kvparts; } else { list($name, $value) = explode('=', $kvparts, 2); } $name = trim($name); $value = trim($value); $attributes = new Requests_Utility_CaseInsensitiveDictionary(); if (!empty($parts)) { foreach ($parts as $part) { if (strpos($part, '=') === false) { $part_key = $part; $part_value = true; } else { list($part_key, $part_value) = explode('=', $part, 2); $part_value = trim($part_value); } $part_key = trim($part_key); $attributes[$part_key] = $part_value; } } return new Requests_Cookie($name, $value, $attributes, array(), $reference_time); } public static function parse_from_headers(Requests_Response_Headers $headers, Requests_IRI $origin = null, $time = null) { $cookie_headers = $headers->getValues('Set-Cookie'); if (empty($cookie_headers)) { return array(); } $cookies = array(); foreach ($cookie_headers as $header) { $parsed = self::parse($header, '', $time); if (empty($parsed->attributes['domain']) && !empty($origin)) { $parsed->attributes['domain'] = $origin->host; $parsed->flags['host-only'] = true; } else { $parsed->flags['host-only'] = false; } $path_is_valid = (!empty($parsed->attributes['path']) && $parsed->attributes['path'][0] === '/'); if (!$path_is_valid && !empty($origin)) { $path = $origin->path; if (substr($path, 0, 1) !== '/') { $path = '/'; } elseif (substr_count($path, '/') === 1) { $path = '/'; } else { $path = substr($path, 0, strrpos($path, '/')); } $parsed->attributes['path'] = $path; } if (!empty($origin) && !$parsed->domain_matches($origin->host)) { continue; } $cookies[$parsed->name] = $parsed; } return $cookies; } public static function parseFromHeaders(Requests_Response_Headers $headers) { return self::parse_from_headers($headers); } } class Requests_IRI { protected $scheme = null; protected $iuserinfo = null; protected $ihost = null; protected $port = null; protected $ipath = ''; protected $iquery = null; protected $ifragment = null; protected $normalization = array( 'acap' => array( 'port' => 674 ), 'dict' => array( 'port' => 2628 ), 'file' => array( 'ihost' => 'localhost' ), 'http' => array( 'port' => 80, ), 'https' => array( 'port' => 443, ), ); public function __toString() { return $this->get_iri(); } public function __set($name, $value) { if (method_exists($this, 'set_' . $name)) { call_user_func(array($this, 'set_' . $name), $value); } elseif ( $name === 'iauthority' || $name === 'iuserinfo' || $name === 'ihost' || $name === 'ipath' || $name === 'iquery' || $name === 'ifragment' ) { call_user_func(array($this, 'set_' . substr($name, 1)), $value); } } public function __get($name) { $props = get_object_vars($this); if ( $name === 'iri' || $name === 'uri' || $name === 'iauthority' || $name === 'authority' ) { $method = 'get_' . $name; $return = $this->$method(); } elseif (array_key_exists($name, $props)) { $return = $this->$name; } elseif (($prop = 'i' . $name) && array_key_exists($prop, $props)) { $name = $prop; $return = $this->$prop; } elseif (($prop = substr($name, 1)) && array_key_exists($prop, $props)) { $name = $prop; $return = $this->$prop; } else { trigger_error('Undefined property: ' . get_class($this) . '::' . $name, E_USER_NOTICE); $return = null; } if ($return === null && isset($this->normalization[$this->scheme][$name])) { return $this->normalization[$this->scheme][$name]; } else { return $return; } } public function __isset($name) { return (method_exists($this, 'get_' . $name) || isset($this->$name)); } public function __unset($name) { if (method_exists($this, 'set_' . $name)) { call_user_func(array($this, 'set_' . $name), ''); } } public function __construct($iri = null) { $this->set_iri($iri); } public static function absolutize($base, $relative) { if (!($relative instanceof Requests_IRI)) { $relative = new Requests_IRI($relative); } if (!$relative->is_valid()) { return false; } elseif ($relative->scheme !== null) { return clone $relative; } if (!($base instanceof Requests_IRI)) { $base = new Requests_IRI($base); } if ($base->scheme === null || !$base->is_valid()) { return false; } if ($relative->get_iri() !== '') { if ($relative->iuserinfo !== null || $relative->ihost !== null || $relative->port !== null) { $target = clone $relative; $target->scheme = $base->scheme; } else { $target = new Requests_IRI; $target->scheme = $base->scheme; $target->iuserinfo = $base->iuserinfo; $target->ihost = $base->ihost; $target->port = $base->port; if ($relative->ipath !== '') { if ($relative->ipath[0] === '/') { $target->ipath = $relative->ipath; } elseif (($base->iuserinfo !== null || $base->ihost !== null || $base->port !== null) && $base->ipath === '') { $target->ipath = '/' . $relative->ipath; } elseif (($last_segment = strrpos($base->ipath, '/')) !== false) { $target->ipath = substr($base->ipath, 0, $last_segment + 1) . $relative->ipath; } else { $target->ipath = $relative->ipath; } $target->ipath = $target->remove_dot_segments($target->ipath); $target->iquery = $relative->iquery; } else { $target->ipath = $base->ipath; if ($relative->iquery !== null) { $target->iquery = $relative->iquery; } elseif ($base->iquery !== null) { $target->iquery = $base->iquery; } } $target->ifragment = $relative->ifragment; } } else { $target = clone $base; $target->ifragment = null; } $target->scheme_normalization(); return $target; } protected function parse_iri($iri) { $iri = trim($iri, "\x20\x09\x0A\x0C\x0D"); $has_match = preg_match('/^((?P<scheme>[^:\/?#]+):)?(\/\/(?P<authority>[^\/?#]*))?(?P<path>[^?#]*)(\?(?P<query>[^#]*))?(#(?P<fragment>.*))?$/', $iri, $match); if (!$has_match) { throw new Requests_Exception('Cannot parse supplied IRI', 'iri.cannot_parse', $iri); } if ($match[1] === '') { $match['scheme'] = null; } if (!isset($match[3]) || $match[3] === '') { $match['authority'] = null; } if (!isset($match[5])) { $match['path'] = ''; } if (!isset($match[6]) || $match[6] === '') { $match['query'] = null; } if (!isset($match[8]) || $match[8] === '') { $match['fragment'] = null; } return $match; } protected function remove_dot_segments($input) { $output = ''; while (strpos($input, './') !== false || strpos($input, '/.') !== false || $input === '.' || $input === '..') { if (strpos($input, '../') === 0) { $input = substr($input, 3); } elseif (strpos($input, './') === 0) { $input = substr($input, 2); } elseif (strpos($input, '/./') === 0) { $input = substr($input, 2); } elseif ($input === '/.') { $input = '/'; } elseif (strpos($input, '/../') === 0) { $input = substr($input, 3); $output = substr_replace($output, '', strrpos($output, '/')); } elseif ($input === '/..') { $input = '/'; $output = substr_replace($output, '', strrpos($output, '/')); } elseif ($input === '.' || $input === '..') { $input = ''; } elseif (($pos = strpos($input, '/', 1)) !== false) { $output .= substr($input, 0, $pos); $input = substr_replace($input, '', 0, $pos); } else { $output .= $input; $input = ''; } } return $output . $input; } protected function replace_invalid_with_pct_encoding($string, $extra_chars, $iprivate = false) { $string = preg_replace_callback('/(?:%[A-Fa-f0-9]{2})+/', array(&$this, 'remove_iunreserved_percent_encoded'), $string); $string = preg_replace('/%(?![A-Fa-f0-9]{2})/', '%25', $string); $extra_chars .= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~%'; $position = 0; $strlen = strlen($string); while (($position += strspn($string, $extra_chars, $position)) < $strlen) { $value = ord($string[$position]); $start = $position; $valid = true; if (($value & 0xE0) === 0xC0) { $character = ($value & 0x1F) << 6; $length = 2; $remaining = 1; } elseif (($value & 0xF0) === 0xE0) { $character = ($value & 0x0F) << 12; $length = 3; $remaining = 2; } elseif (($value & 0xF8) === 0xF0) { $character = ($value & 0x07) << 18; $length = 4; $remaining = 3; } else { $valid = false; $length = 1; $remaining = 0; } if ($remaining) { if ($position + $length <= $strlen) { for ($position++; $remaining; $position++) { $value = ord($string[$position]); if (($value & 0xC0) === 0x80) { $character |= ($value & 0x3F) << (--$remaining * 6); } else { $valid = false; $position--; break; } } } else { $position = $strlen - 1; $valid = false; } } if ( !$valid || $length > 1 && $character <= 0x7F || $length > 2 && $character <= 0x7FF || $length > 3 && $character <= 0xFFFF || ($character & 0xFFFE) === 0xFFFE || $character >= 0xFDD0 && $character <= 0xFDEF || ( $character > 0xD7FF && $character < 0xF900 || $character < 0xA0 || $character > 0xEFFFD ) && ( !$iprivate || $character < 0xE000 || $character > 0x10FFFD ) ) { if ($valid) { $position--; } for ($j = $start; $j <= $position; $j++) { $string = substr_replace($string, sprintf('%%%02X', ord($string[$j])), $j, 1); $j += 2; $position += 2; $strlen += 2; } } } return $string; } protected function remove_iunreserved_percent_encoded($match) { $bytes = explode('%', $match[0]); $string = ''; $remaining = 0; for ($i = 1, $len = count($bytes); $i < $len; $i++) { $value = hexdec($bytes[$i]); if (!$remaining) { $start = $i; $valid = true; if ($value <= 0x7F) { $character = $value; $length = 1; } elseif (($value & 0xE0) === 0xC0) { $character = ($value & 0x1F) << 6; $length = 2; $remaining = 1; } elseif (($value & 0xF0) === 0xE0) { $character = ($value & 0x0F) << 12; $length = 3; $remaining = 2; } elseif (($value & 0xF8) === 0xF0) { $character = ($value & 0x07) << 18; $length = 4; $remaining = 3; } else { $valid = false; $remaining = 0; } } else { if (($value & 0xC0) === 0x80) { $remaining--; $character |= ($value & 0x3F) << ($remaining * 6); } else { $valid = false; $remaining = 0; $i--; } } if (!$remaining) { if ( !$valid || $length > 1 && $character <= 0x7F || $length > 2 && $character <= 0x7FF || $length > 3 && $character <= 0xFFFF || $character < 0x2D || $character > 0xEFFFD || ($character & 0xFFFE) === 0xFFFE || $character >= 0xFDD0 && $character <= 0xFDEF || $character === 0x2F || $character > 0x39 && $character < 0x41 || $character > 0x5A && $character < 0x61 || $character > 0x7A && $character < 0x7E || $character > 0x7E && $character < 0xA0 || $character > 0xD7FF && $character < 0xF900 ) { for ($j = $start; $j <= $i; $j++) { $string .= '%' . strtoupper($bytes[$j]); } } else { for ($j = $start; $j <= $i; $j++) { $string .= chr(hexdec($bytes[$j])); } } } } if ($remaining) { for ($j = $start; $j < $len; $j++) { $string .= '%' . strtoupper($bytes[$j]); } } return $string; } protected function scheme_normalization() { if (isset($this->normalization[$this->scheme]['iuserinfo']) && $this->iuserinfo === $this->normalization[$this->scheme]['iuserinfo']) { $this->iuserinfo = null; } if (isset($this->normalization[$this->scheme]['ihost']) && $this->ihost === $this->normalization[$this->scheme]['ihost']) { $this->ihost = null; } if (isset($this->normalization[$this->scheme]['port']) && $this->port === $this->normalization[$this->scheme]['port']) { $this->port = null; } if (isset($this->normalization[$this->scheme]['ipath']) && $this->ipath === $this->normalization[$this->scheme]['ipath']) { $this->ipath = ''; } if (isset($this->ihost) && empty($this->ipath)) { $this->ipath = '/'; } if (isset($this->normalization[$this->scheme]['iquery']) && $this->iquery === $this->normalization[$this->scheme]['iquery']) { $this->iquery = null; } if (isset($this->normalization[$this->scheme]['ifragment']) && $this->ifragment === $this->normalization[$this->scheme]['ifragment']) { $this->ifragment = null; } } public function is_valid() { $isauthority = $this->iuserinfo !== null || $this->ihost !== null || $this->port !== null; if ($this->ipath !== '' && ( $isauthority && $this->ipath[0] !== '/' || ( $this->scheme === null && !$isauthority && strpos($this->ipath, ':') !== false && (strpos($this->ipath, '/') === false ? true : strpos($this->ipath, ':') < strpos($this->ipath, '/')) ) ) ) { return false; } return true; } protected function set_iri($iri) { static $cache; if (!$cache) { $cache = array(); } if ($iri === null) { return true; } if (isset($cache[$iri])) { list($this->scheme, $this->iuserinfo, $this->ihost, $this->port, $this->ipath, $this->iquery, $this->ifragment, $return) = $cache[$iri]; return $return; } $parsed = $this->parse_iri((string) $iri); $return = $this->set_scheme($parsed['scheme']) && $this->set_authority($parsed['authority']) && $this->set_path($parsed['path']) && $this->set_query($parsed['query']) && $this->set_fragment($parsed['fragment']); $cache[$iri] = array($this->scheme, $this->iuserinfo, $this->ihost, $this->port, $this->ipath, $this->iquery, $this->ifragment, $return); return $return; } protected function set_scheme($scheme) { if ($scheme === null) { $this->scheme = null; } elseif (!preg_match('/^[A-Za-z][0-9A-Za-z+\-.]*$/', $scheme)) { $this->scheme = null; return false; } else { $this->scheme = strtolower($scheme); } return true; } protected function set_authority($authority) { static $cache; if (!$cache) { $cache = array(); } if ($authority === null) { $this->iuserinfo = null; $this->ihost = null; $this->port = null; return true; } if (isset($cache[$authority])) { list($this->iuserinfo, $this->ihost, $this->port, $return) = $cache[$authority]; return $return; } $remaining = $authority; if (($iuserinfo_end = strrpos($remaining, '@')) !== false) { $iuserinfo = substr($remaining, 0, $iuserinfo_end); $remaining = substr($remaining, $iuserinfo_end + 1); } else { $iuserinfo = null; } if (($port_start = strpos($remaining, ':', strpos($remaining, ']'))) !== false) { $port = substr($remaining, $port_start + 1); if ($port === false || $port === '') { $port = null; } $remaining = substr($remaining, 0, $port_start); } else { $port = null; } $return = $this->set_userinfo($iuserinfo) && $this->set_host($remaining) && $this->set_port($port); $cache[$authority] = array($this->iuserinfo, $this->ihost, $this->port, $return); return $return; } protected function set_userinfo($iuserinfo) { if ($iuserinfo === null) { $this->iuserinfo = null; } else { $this->iuserinfo = $this->replace_invalid_with_pct_encoding($iuserinfo, '!$&\'()*+,;=:'); $this->scheme_normalization(); } return true; } protected function set_host($ihost) { if ($ihost === null) { $this->ihost = null; return true; } if (substr($ihost, 0, 1) === '[' && substr($ihost, -1) === ']') { if (Requests_IPv6::check_ipv6(substr($ihost, 1, -1))) { $this->ihost = '[' . Requests_IPv6::compress(substr($ihost, 1, -1)) . ']'; } else { $this->ihost = null; return false; } } else { $ihost = $this->replace_invalid_with_pct_encoding($ihost, '!$&\'()*+,;='); $position = 0; $strlen = strlen($ihost); while (($position += strcspn($ihost, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ%', $position)) < $strlen) { if ($ihost[$position] === '%') { $position += 3; } else { $ihost[$position] = strtolower($ihost[$position]); $position++; } } $this->ihost = $ihost; } $this->scheme_normalization(); return true; } protected function set_port($port) { if ($port === null) { $this->port = null; return true; } if (strspn($port, '0123456789') === strlen($port)) { $this->port = (int) $port; $this->scheme_normalization(); return true; } $this->port = null; return false; } protected function set_path($ipath) { static $cache; if (!$cache) { $cache = array(); } $ipath = (string) $ipath; if (isset($cache[$ipath])) { $this->ipath = $cache[$ipath][(int) ($this->scheme !== null)]; } else { $valid = $this->replace_invalid_with_pct_encoding($ipath, '!$&\'()*+,;=@:/'); $removed = $this->remove_dot_segments($valid); $cache[$ipath] = array($valid, $removed); $this->ipath = ($this->scheme !== null) ? $removed : $valid; } $this->scheme_normalization(); return true; } protected function set_query($iquery) { if ($iquery === null) { $this->iquery = null; } else { $this->iquery = $this->replace_invalid_with_pct_encoding($iquery, '!$&\'()*+,;=:@/?', true); $this->scheme_normalization(); } return true; } protected function set_fragment($ifragment) { if ($ifragment === null) { $this->ifragment = null; } else { $this->ifragment = $this->replace_invalid_with_pct_encoding($ifragment, '!$&\'()*+,;=:@/?'); $this->scheme_normalization(); } return true; } protected function to_uri($string) { if (!is_string($string)) { return false; } static $non_ascii; if (!$non_ascii) { $non_ascii = implode('', range("\x80", "\xFF")); } $position = 0; $strlen = strlen($string); while (($position += strcspn($string, $non_ascii, $position)) < $strlen) { $string = substr_replace($string, sprintf('%%%02X', ord($string[$position])), $position, 1); $position += 3; $strlen += 2; } return $string; } protected function get_iri() { if (!$this->is_valid()) { return false; } $iri = ''; if ($this->scheme !== null) { $iri .= $this->scheme . ':'; } if (($iauthority = $this->get_iauthority()) !== null) { $iri .= '//' . $iauthority; } $iri .= $this->ipath; if ($this->iquery !== null) { $iri .= '?' . $this->iquery; } if ($this->ifragment !== null) { $iri .= '#' . $this->ifragment; } return $iri; } protected function get_uri() { return $this->to_uri($this->get_iri()); } protected function get_iauthority() { if ($this->iuserinfo === null && $this->ihost === null && $this->port === null) { return null; } $iauthority = ''; if ($this->iuserinfo !== null) { $iauthority .= $this->iuserinfo . '@'; } if ($this->ihost !== null) { $iauthority .= $this->ihost; } if ($this->port !== null) { $iauthority .= ':' . $this->port; } return $iauthority; } protected function get_authority() { $iauthority = $this->get_iauthority(); if (is_string($iauthority)) { return $this->to_uri($iauthority); } else { return $iauthority; } } } class WP_Http { const HTTP_CONTINUE = 100; const SWITCHING_PROTOCOLS = 101; const PROCESSING = 102; const OK = 200; const CREATED = 201; const ACCEPTED = 202; const NON_AUTHORITATIVE_INFORMATION = 203; const NO_CONTENT = 204; const RESET_CONTENT = 205; const PARTIAL_CONTENT = 206; const MULTI_STATUS = 207; const IM_USED = 226; const MULTIPLE_CHOICES = 300; const MOVED_PERMANENTLY = 301; const FOUND = 302; const SEE_OTHER = 303; const NOT_MODIFIED = 304; const USE_PROXY = 305; const RESERVED = 306; const TEMPORARY_REDIRECT = 307; const PERMANENT_REDIRECT = 308; const BAD_REQUEST = 400; const UNAUTHORIZED = 401; const PAYMENT_REQUIRED = 402; const FORBIDDEN = 403; const NOT_FOUND = 404; const METHOD_NOT_ALLOWED = 405; const NOT_ACCEPTABLE = 406; const PROXY_AUTHENTICATION_REQUIRED = 407; const REQUEST_TIMEOUT = 408; const CONFLICT = 409; const GONE = 410; const LENGTH_REQUIRED = 411; const PRECONDITION_FAILED = 412; const REQUEST_ENTITY_TOO_LARGE = 413; const REQUEST_URI_TOO_LONG = 414; const UNSUPPORTED_MEDIA_TYPE = 415; const REQUESTED_RANGE_NOT_SATISFIABLE = 416; const EXPECTATION_FAILED = 417; const IM_A_TEAPOT = 418; const MISDIRECTED_REQUEST = 421; const UNPROCESSABLE_ENTITY = 422; const LOCKED = 423; const FAILED_DEPENDENCY = 424; const UPGRADE_REQUIRED = 426; const PRECONDITION_REQUIRED = 428; const TOO_MANY_REQUESTS = 429; const REQUEST_HEADER_FIELDS_TOO_LARGE = 431; const UNAVAILABLE_FOR_LEGAL_REASONS = 451; const INTERNAL_SERVER_ERROR = 500; const NOT_IMPLEMENTED = 501; const BAD_GATEWAY = 502; const SERVICE_UNAVAILABLE = 503; const GATEWAY_TIMEOUT = 504; const HTTP_VERSION_NOT_SUPPORTED = 505; const VARIANT_ALSO_NEGOTIATES = 506; const INSUFFICIENT_STORAGE = 507; const NOT_EXTENDED = 510; const NETWORK_AUTHENTICATION_REQUIRED = 511; public function request( $url, $args = array() ) { $defaults = array( 'method' => 'GET', 'timeout' => apply_filters( 'http_request_timeout', 5 ), 'redirection' => apply_filters( 'http_request_redirection_count', 5 ), 'httpversion' => apply_filters( 'http_request_version', '1.0' ), 'user-agent' => apply_filters( 'http_headers_useragent', ''), 'reject_unsafe_urls' => apply_filters( 'http_request_reject_unsafe_urls', false ), 'blocking' => true, 'headers' => array(), 'cookies' => array(), 'body' => null, 'compress' => false, 'decompress' => true, 'sslverify' => false, 'stream' => false, 'filename' => null, 'limit_response_size' => null, ); $args = wp_parse_args( $args ); if ( isset($args['method']) && 'HEAD' == $args['method'] ) $defaults['redirection'] = 0; $r = wp_parse_args( $args, $defaults ); $r = apply_filters( 'http_request_args', $r, $url ); if ( ! isset( $r['_redirection'] ) ) $r['_redirection'] = $r['redirection']; $pre = apply_filters( 'pre_http_request', false, $r, $url ); if ( false !== $pre ) return $pre; if ( function_exists( 'wp_kses_bad_protocol' ) ) { if ( $r['reject_unsafe_urls'] ) { $url = wp_http_validate_url( $url ); } if ( $url ) { $url = wp_kses_bad_protocol( $url, array( 'http', 'https', 'ssl' ) ); } } $arrURL = @parse_url( $url ); if ( empty( $url ) || empty( $arrURL['scheme'] ) ) { return new WP_Error('http_request_failed', 'A valid URL was not provided.'); } if ( $this->block_request( $url ) ) { return new WP_Error( 'http_request_failed', __( 'User has blocked requests through HTTP.' ) ); } if ( $r['stream'] ) { if ( empty( $r['filename'] ) ) { $r['filename'] = get_temp_dir() . basename( $url ); } $r['blocking'] = true; if ( ! wp_is_writable( dirname( $r['filename'] ) ) ) { return new WP_Error( 'http_request_failed', __( 'Destination directory for file streaming does not exist or is not writable.' ) ); } } if ( is_null( $r['headers'] ) ) { $r['headers'] = array(); } if ( ! is_array( $r['headers'] ) ) { $processedHeaders = WP_Http::processHeaders( $r['headers'] ); $r['headers'] = $processedHeaders['headers']; } $headers = $r['headers']; $data = $r['body']; $type = $r['method']; $options = array( 'timeout' => $r['timeout'], 'useragent' => $r['user-agent'], 'blocking' => $r['blocking'], 'hooks' => new WP_HTTP_Requests_Hooks( $url, $r ), ); $options['hooks']->register( 'requests.before_redirect', array( get_class(), 'browser_redirect_compatibility' ) ); if ( function_exists( 'wp_kses_bad_protocol' ) && $r['reject_unsafe_urls'] ) { $options['hooks']->register( 'requests.before_redirect', array( get_class(), 'validate_redirects' ) ); } if ( $r['stream'] ) { $options['filename'] = $r['filename']; } if ( empty( $r['redirection'] ) ) { $options['follow_redirects'] = false; } else { $options['redirects'] = $r['redirection']; } if ( isset( $r['limit_response_size'] ) ) { $options['max_bytes'] = $r['limit_response_size']; } if ( ! empty( $r['cookies'] ) ) { $options['cookies'] = WP_Http::normalize_cookies( $r['cookies'] ); } if ( 'HEAD' !== $type && 'GET' !== $type ) { $options['data_format'] = 'body'; } mbstring_binary_safe_encoding(); try { $requests_response = Requests::request( $url, $headers, $data, $type, $options ); $http_response = new WP_HTTP_Requests_Response( $requests_response, $r['filename'] ); $response = $http_response->to_array(); $response['http_response'] = $http_response; } catch ( Requests_Exception $e ) { $response = new WP_Error( 'http_request_failed', $e->getMessage() ); } reset_mbstring_encoding(); do_action( 'http_api_debug', $response, 'response', 'Requests', $r, $url ); if ( is_wp_error( $response ) ) { return $response; } if ( ! $r['blocking'] ) { return array( 'headers' => array(), 'body' => '', 'response' => array( 'code' => false, 'message' => false, ), 'cookies' => array(), 'http_response' => null, ); } return apply_filters( 'http_response', $response, $r, $url ); } public static function normalize_cookies( $cookies ) { $cookie_jar = new Requests_Cookie_Jar(); foreach ( $cookies as $name => $value ) { if ( $value instanceof WP_Http_Cookie ) { $cookie_jar[ $value->name ] = new Requests_Cookie( $value->name, $value->value, $value->get_attributes() ); } elseif ( is_scalar( $value ) ) { $cookie_jar[ $name ] = new Requests_Cookie( $name, $value ); } } return $cookie_jar; } public static function browser_redirect_compatibility( $location, $headers, $data, &$options, $original ) { if ( $original->status_code === 302 ) { $options['type'] = Requests::GET; } } public static function validate_redirects( $location ) { if ( ! wp_http_validate_url( $location ) ) { throw new Requests_Exception( __('A valid URL was not provided.'), 'wp_http.redirect_failed_validation' ); } } public function _get_first_available_transport( $args, $url = null ) { $transports = array( 'curl', 'streams' ); $request_order = apply_filters( 'http_api_transports', $transports, $args, $url ); foreach ( $request_order as $transport ) { if ( in_array( $transport, $transports ) ) { $transport = ucfirst( $transport ); } $class = 'WP_Http_' . $transport; if ( !call_user_func( array( $class, 'test' ), $args, $url ) ) continue; return $class; } return false; } private function _dispatch_request( $url, $args ) { static $transports = array(); $class = $this->_get_first_available_transport( $args, $url ); if ( !$class ) return new WP_Error( 'http_failure', __( 'There are no HTTP transports available which can complete the requested request.' ) ); if ( empty( $transports[$class] ) ) $transports[$class] = new $class; $response = $transports[$class]->request( $url, $args ); do_action( 'http_api_debug', $response, 'response', $class, $args, $url ); if ( is_wp_error( $response ) ) return $response; return apply_filters( 'http_response', $response, $args, $url ); } public function post($url, $args = array()) { $defaults = array('method' => 'POST'); $r = wp_parse_args( $args, $defaults ); return $this->request($url, $r); } public function get($url, $args = array()) { $defaults = array('method' => 'GET'); $r = wp_parse_args( $args, $defaults ); return $this->request($url, $r); } public function head($url, $args = array()) { $defaults = array('method' => 'HEAD'); $r = wp_parse_args( $args, $defaults ); return $this->request($url, $r); } public static function processResponse($strResponse) { $res = explode("\r\n\r\n", $strResponse, 2); return array('headers' => $res[0], 'body' => isset($res[1]) ? $res[1] : ''); } public static function processHeaders( $headers, $url = '' ) { if ( is_string($headers) ) { $headers = str_replace("\r\n", "\n", $headers); $headers = preg_replace('/\n[ \t]/', ' ', $headers); $headers = explode("\n", $headers); } $response = array('code' => 0, 'message' => ''); for ( $i = count($headers)-1; $i >= 0; $i-- ) { if ( !empty($headers[$i]) && false === strpos($headers[$i], ':') ) { $headers = array_splice($headers, $i); break; } } $cookies = array(); $newheaders = array(); foreach ( (array) $headers as $tempheader ) { if ( empty($tempheader) ) continue; if ( false === strpos($tempheader, ':') ) { $stack = explode(' ', $tempheader, 3); $stack[] = ''; list( , $response['code'], $response['message']) = $stack; continue; } list($key, $value) = explode(':', $tempheader, 2); $key = strtolower( $key ); $value = trim( $value ); if ( isset( $newheaders[ $key ] ) ) { if ( ! is_array( $newheaders[ $key ] ) ) $newheaders[$key] = array( $newheaders[ $key ] ); $newheaders[ $key ][] = $value; } else { $newheaders[ $key ] = $value; } if ( 'set-cookie' == $key ) $cookies[] = new WP_Http_Cookie( $value, $url ); } $response['code'] = intval( $response['code'] ); return array('response' => $response, 'headers' => $newheaders, 'cookies' => $cookies); } public static function buildCookieHeader( &$r ) { if ( ! empty($r['cookies']) ) { foreach ( $r['cookies'] as $name => $value ) { if ( ! is_object( $value ) ) $r['cookies'][ $name ] = new WP_Http_Cookie( array( 'name' => $name, 'value' => $value ) ); } $cookies_header = ''; foreach ( (array) $r['cookies'] as $cookie ) { $cookies_header .= $cookie->getHeaderValue() . '; '; } $cookies_header = substr( $cookies_header, 0, -2 ); $r['headers']['cookie'] = $cookies_header; } } public static function chunkTransferDecode( $body ) { if ( ! preg_match( '/^([0-9a-f]+)[^\r\n]*\r\n/i', trim( $body ) ) ) return $body; $parsed_body = ''; $body_original = $body; while ( true ) { $has_chunk = (bool) preg_match( '/^([0-9a-f]+)[^\r\n]*\r\n/i', $body, $match ); if ( ! $has_chunk || empty( $match[1] ) ) return $body_original; $length = hexdec( $match[1] ); $chunk_length = strlen( $match[0] ); $parsed_body .= substr( $body, $chunk_length, $length ); $body = substr( $body, $length + $chunk_length ); if ( '0' === trim( $body ) ) return $parsed_body; } } public function block_request($uri) { if ( ! defined( 'WP_HTTP_BLOCK_EXTERNAL' ) || ! WP_HTTP_BLOCK_EXTERNAL ) return false; $check = parse_url($uri); if ( ! $check ) return true; $home = parse_url( get_option('siteurl') ); if ( 'localhost' == $check['host'] || ( isset( $home['host'] ) && $home['host'] == $check['host'] ) ) { return apply_filters( 'block_local_requests', false ); } if ( !defined('WP_ACCESSIBLE_HOSTS') ) return true; static $accessible_hosts = null; static $wildcard_regex = array(); if ( null === $accessible_hosts ) { $accessible_hosts = preg_split('|,\s*|', WP_ACCESSIBLE_HOSTS); if ( false !== strpos(WP_ACCESSIBLE_HOSTS, '*') ) { $wildcard_regex = array(); foreach ( $accessible_hosts as $host ) $wildcard_regex[] = str_replace( '\*', '.+', preg_quote( $host, '/' ) ); $wildcard_regex = '/^(' . implode('|', $wildcard_regex) . ')$/i'; } } if ( !empty($wildcard_regex) ) return !preg_match($wildcard_regex, $check['host']); else return !in_array( $check['host'], $accessible_hosts ); } protected static function parse_url( $url ) { _deprecated_function( __METHOD__, '4.4.0', 'wp_parse_url()' ); return wp_parse_url( $url ); } public static function make_absolute_url( $maybe_relative_path, $url ) { if ( empty( $url ) ) return $maybe_relative_path; if ( ! $url_parts = wp_parse_url( $url ) ) { return $maybe_relative_path; } if ( ! $relative_url_parts = wp_parse_url( $maybe_relative_path ) ) { return $maybe_relative_path; } if ( ! empty( $relative_url_parts['scheme'] ) ) { return $maybe_relative_path; } $absolute_path = $url_parts['scheme'] . '://'; if ( isset( $relative_url_parts['host'] ) ) { $absolute_path .= $relative_url_parts['host']; if ( isset( $relative_url_parts['port'] ) ) $absolute_path .= ':' . $relative_url_parts['port']; } else { $absolute_path .= $url_parts['host']; if ( isset( $url_parts['port'] ) ) $absolute_path .= ':' . $url_parts['port']; } $path = ! empty( $url_parts['path'] ) ? $url_parts['path'] : '/'; if ( ! empty( $relative_url_parts['path'] ) && '/' == $relative_url_parts['path'][0] ) { $path = $relative_url_parts['path']; } elseif ( ! empty( $relative_url_parts['path'] ) ) { $path = substr( $path, 0, strrpos( $path, '/' ) + 1 ); $path .= $relative_url_parts['path']; while ( strpos( $path, '../' ) > 1 ) { $path = preg_replace( '![^/]+/\.\./!', '', $path ); } $path = preg_replace( '!^/(\.\./)+!', '', $path ); } if ( ! empty( $relative_url_parts['query'] ) ) $path .= '?' . $relative_url_parts['query']; return $absolute_path . '/' . ltrim( $path, '/' ); } public static function handle_redirects( $url, $args, $response ) { if ( ! isset( $response['headers']['location'] ) || 0 === $args['_redirection'] ) return false; if ( $response['response']['code'] > 399 || $response['response']['code'] < 300 ) return false; if ( $args['redirection']-- <= 0 ) return new WP_Error( 'http_request_failed', __('Too many redirects.') ); $redirect_location = $response['headers']['location']; if ( is_array( $redirect_location ) ) $redirect_location = array_pop( $redirect_location ); $redirect_location = WP_Http::make_absolute_url( $redirect_location, $url ); if ( 'POST' == $args['method'] ) { if ( in_array( $response['response']['code'], array( 302, 303 ) ) ) $args['method'] = 'GET'; } if ( ! empty( $response['cookies'] ) ) { foreach ( $response['cookies'] as $cookie ) { if ( $cookie->test( $redirect_location ) ) $args['cookies'][] = $cookie; } } return wp_remote_request( $redirect_location, $args ); } } class Requests { const POST = 'POST'; const PUT = 'PUT'; const GET = 'GET'; const HEAD = 'HEAD'; const DELETE = 'DELETE'; const OPTIONS = 'OPTIONS'; const TRACE = 'TRACE'; const PATCH = 'PATCH'; const BUFFER_SIZE = 1160; const VERSION = '1.7'; protected static $transports = array(); public static $transport = array(); protected static $certificate_path; private function __construct() {} public static function add_transport($transport) { if (empty(self::$transports)) { self::$transports = array( 'Requests_Transport_cURL', 'Requests_Transport_fsockopen', ); } self::$transports = array_merge(self::$transports, array($transport)); } protected static function get_transport($capabilities = array()) { ksort($capabilities); $cap_string = serialize($capabilities); if (isset(self::$transport[$cap_string]) && self::$transport[$cap_string] !== null) { return new self::$transport[$cap_string](); } if (empty(self::$transports)) { self::$transports = array( 'Requests_Transport_cURL', 'Requests_Transport_fsockopen', ); } foreach (self::$transports as $class) { if (!class_exists($class)) { continue; } $result = call_user_func(array($class, 'test'), $capabilities); if ($result) { self::$transport[$cap_string] = $class; break; } } if (self::$transport[$cap_string] === null) { throw new Requests_Exception('No working transports found', 'notransport', self::$transports); } return new self::$transport[$cap_string](); } public static function get($url, $headers = array(), $options = array()) { return self::request($url, $headers, null, self::GET, $options); } public static function head($url, $headers = array(), $options = array()) { return self::request($url, $headers, null, self::HEAD, $options); } public static function delete($url, $headers = array(), $options = array()) { return self::request($url, $headers, null, self::DELETE, $options); } public static function trace($url, $headers = array(), $options = array()) { return self::request($url, $headers, null, self::TRACE, $options); } public static function post($url, $headers = array(), $data = array(), $options = array()) { return self::request($url, $headers, $data, self::POST, $options); } public static function put($url, $headers = array(), $data = array(), $options = array()) { return self::request($url, $headers, $data, self::PUT, $options); } public static function options($url, $headers = array(), $data = array(), $options = array()) { return self::request($url, $headers, $data, self::OPTIONS, $options); } public static function patch($url, $headers, $data = array(), $options = array()) { return self::request($url, $headers, $data, self::PATCH, $options); } public static function request($url, $headers = array(), $data = array(), $type = self::GET, $options = array()) { if (empty($options['type'])) { $options['type'] = $type; } $options = array_merge(self::get_default_options(), $options); self::set_defaults($url, $headers, $data, $type, $options); $options['hooks']->dispatch('requests.before_request', array(&$url, &$headers, &$data, &$type, &$options)); if (!empty($options['transport'])) { $transport = $options['transport']; if (is_string($options['transport'])) { $transport = new $transport(); } } else { $need_ssl = (0 === stripos($url, 'https://')); $capabilities = array('ssl' => $need_ssl); $transport = self::get_transport($capabilities); } $response = $transport->request($url, $headers, $data, $options); $options['hooks']->dispatch('requests.before_parse', array(&$response, $url, $headers, $data, $type, $options)); return self::parse_response($response, $url, $headers, $data, $options); } public static function request_multiple($requests, $options = array()) { $options = array_merge(self::get_default_options(true), $options); if (!empty($options['hooks'])) { $options['hooks']->register('transport.internal.parse_response', array('Requests', 'parse_multiple')); if (!empty($options['complete'])) { $options['hooks']->register('multiple.request.complete', $options['complete']); } } foreach ($requests as $id => &$request) { if (!isset($request['headers'])) { $request['headers'] = array(); } if (!isset($request['data'])) { $request['data'] = array(); } if (!isset($request['type'])) { $request['type'] = self::GET; } if (!isset($request['options'])) { $request['options'] = $options; $request['options']['type'] = $request['type']; } else { if (empty($request['options']['type'])) { $request['options']['type'] = $request['type']; } $request['options'] = array_merge($options, $request['options']); } self::set_defaults($request['url'], $request['headers'], $request['data'], $request['type'], $request['options']); if ($request['options']['hooks'] !== $options['hooks']) { $request['options']['hooks']->register('transport.internal.parse_response', array('Requests', 'parse_multiple')); if (!empty($request['options']['complete'])) { $request['options']['hooks']->register('multiple.request.complete', $request['options']['complete']); } } } unset($request); if (!empty($options['transport'])) { $transport = $options['transport']; if (is_string($options['transport'])) { $transport = new $transport(); } } else { $transport = self::get_transport(); } $responses = $transport->request_multiple($requests, $options); foreach ($responses as $id => &$response) { if (is_string($response)) { $request = $requests[$id]; self::parse_multiple($response, $request); $request['options']['hooks']->dispatch('multiple.request.complete', array(&$response, $id)); } } return $responses; } protected static function get_default_options($multirequest = false) { $defaults = array( 'timeout' => 10, 'connect_timeout' => 10, 'useragent' => 'php-requests/' . self::VERSION, 'protocol_version' => 1.1, 'redirected' => 0, 'redirects' => 10, 'follow_redirects' => true, 'blocking' => true, 'type' => self::GET, 'filename' => false, 'auth' => false, 'proxy' => false, 'cookies' => false, 'max_bytes' => false, 'idn' => true, 'hooks' => null, 'transport' => null, 'verify' => Requests::get_certificate_path(), 'verifyname' => true, ); if ($multirequest !== false) { $defaults['complete'] = null; } return $defaults; } public static function get_certificate_path() { if ( ! empty( Requests::$certificate_path ) ) { return Requests::$certificate_path; } return dirname(__FILE__) . '/Requests/Transport/cacert.pem'; } public static function set_certificate_path( $path ) { Requests::$certificate_path = $path; } protected static function set_defaults(&$url, &$headers, &$data, &$type, &$options) { if (!preg_match('/^http(s)?:\/\//i', $url, $matches)) { throw new Requests_Exception('Only HTTP(S) requests are handled.', 'nonhttp', $url); } if (empty($options['hooks'])) { $options['hooks'] = new Requests_Hooks(); } if (is_array($options['auth'])) { $options['auth'] = new Requests_Auth_Basic($options['auth']); } if ($options['auth'] !== false) { $options['auth']->register($options['hooks']); } if (is_string($options['proxy']) || is_array($options['proxy'])) { $options['proxy'] = new Requests_Proxy_HTTP($options['proxy']); } if ($options['proxy'] !== false) { $options['proxy']->register($options['hooks']); } if (is_array($options['cookies'])) { $options['cookies'] = new Requests_Cookie_Jar($options['cookies']); } elseif (empty($options['cookies'])) { $options['cookies'] = new Requests_Cookie_Jar(); } if ($options['cookies'] !== false) { $options['cookies']->register($options['hooks']); } if ($options['idn'] !== false) { $iri = new Requests_IRI($url); $iri->host = Requests_IDNAEncoder::encode($iri->ihost); $url = $iri->uri; } $type = strtoupper($type); if (!isset($options['data_format'])) { if (in_array($type, array(self::HEAD, self::GET, self::DELETE))) { $options['data_format'] = 'query'; } else { $options['data_format'] = 'body'; } } } protected static function parse_response($headers, $url, $req_headers, $req_data, $options) { $return = new Requests_Response(); if (!$options['blocking']) { return $return; } $return->raw = $headers; $return->url = $url; if (!$options['filename']) { if (($pos = strpos($headers, "\r\n\r\n")) === false) { throw new Requests_Exception('Missing header/body separator', 'requests.no_crlf_separator'); } $headers = substr($return->raw, 0, $pos); $return->body = substr($return->raw, $pos + strlen("\n\r\n\r")); } else { $return->body = ''; } $headers = str_replace("\r\n", "\n", $headers); $headers = preg_replace('/\n[ \t]/', ' ', $headers); $headers = explode("\n", $headers); preg_match('#^HTTP/(1\.\d)[ \t]+(\d+)#i', array_shift($headers), $matches); if (empty($matches)) { throw new Requests_Exception('Response could not be parsed', 'noversion', $headers); } $return->protocol_version = (float) $matches[1]; $return->status_code = (int) $matches[2]; if ($return->status_code >= 200 && $return->status_code < 300) { $return->success = true; } foreach ($headers as $header) { list($key, $value) = explode(':', $header, 2); $value = trim($value); preg_replace('#(\s+)#i', ' ', $value); $return->headers[$key] = $value; } if (isset($return->headers['transfer-encoding'])) { $return->body = self::decode_chunked($return->body); unset($return->headers['transfer-encoding']); } if (isset($return->headers['content-encoding'])) { $return->body = self::decompress($return->body); } if (isset($return->headers['connection'])) { unset($return->headers['connection']); } $options['hooks']->dispatch('requests.before_redirect_check', array(&$return, $req_headers, $req_data, $options)); if ($return->is_redirect() && $options['follow_redirects'] === true) { if (isset($return->headers['location']) && $options['redirected'] < $options['redirects']) { if ($return->status_code === 303) { $options['type'] = self::GET; } $options['redirected']++; $location = $return->headers['location']; if (strpos($location, 'http://') !== 0 && strpos($location, 'https://') !== 0) { $location = Requests_IRI::absolutize($url, $location); $location = $location->uri; } $hook_args = array( &$location, &$req_headers, &$req_data, &$options, $return ); $options['hooks']->dispatch('requests.before_redirect', $hook_args); $redirected = self::request($location, $req_headers, $req_data, $options['type'], $options); $redirected->history[] = $return; return $redirected; } elseif ($options['redirected'] >= $options['redirects']) { throw new Requests_Exception('Too many redirects', 'toomanyredirects', $return); } } $return->redirects = $options['redirected']; $options['hooks']->dispatch('requests.after_request', array(&$return, $req_headers, $req_data, $options)); return $return; } public static function parse_multiple(&$response, $request) { try { $url = $request['url']; $headers = $request['headers']; $data = $request['data']; $options = $request['options']; $response = self::parse_response($response, $url, $headers, $data, $options); } catch (Requests_Exception $e) { $response = $e; } } protected static function decode_chunked($data) { if (!preg_match('/^([0-9a-f]+)(?:;(?:[\w-]*)(?:=(?:(?:[\w-]*)*|"(?:[^\r\n])*"))?)*\r\n/i', trim($data))) { return $data; } $decoded = ''; $encoded = $data; while (true) { $is_chunked = (bool) preg_match('/^([0-9a-f]+)(?:;(?:[\w-]*)(?:=(?:(?:[\w-]*)*|"(?:[^\r\n])*"))?)*\r\n/i', $encoded, $matches); if (!$is_chunked) { return $data; } $length = hexdec(trim($matches[1])); if ($length === 0) { return $decoded; } $chunk_length = strlen($matches[0]); $decoded .= substr($encoded, $chunk_length, $length); $encoded = substr($encoded, $chunk_length + $length + 2); if (trim($encoded) === '0' || empty($encoded)) { return $decoded; } } } public static function flatten($array) { $return = array(); foreach ($array as $key => $value) { $return[] = sprintf('%s: %s', $key, $value); } return $return; } public static function flattern($array) { return self::flatten($array); } public static function decompress($data) { if (substr($data, 0, 2) !== "\x1f\x8b" && substr($data, 0, 2) !== "\x78\x9c") { return $data; } if (function_exists('gzdecode') && ($decoded = @gzdecode($data)) !== false) { return $decoded; } elseif (function_exists('gzinflate') && ($decoded = @gzinflate($data)) !== false) { return $decoded; } elseif (($decoded = self::compatible_gzinflate($data)) !== false) { return $decoded; } elseif (function_exists('gzuncompress') && ($decoded = @gzuncompress($data)) !== false) { return $decoded; } return $data; } public static function compatible_gzinflate($gzData) { if (substr($gzData, 0, 3) == "\x1f\x8b\x08") { $i = 10; $flg = ord(substr($gzData, 3, 1)); if ($flg > 0) { if ($flg & 4) { list($xlen) = unpack('v', substr($gzData, $i, 2)); $i = $i + 2 + $xlen; } if ($flg & 8) { $i = strpos($gzData, "\0", $i) + 1; } if ($flg & 16) { $i = strpos($gzData, "\0", $i) + 1; } if ($flg & 2) { $i = $i + 2; } } $decompressed = self::compatible_gzinflate(substr($gzData, $i)); if (false !== $decompressed) { return $decompressed; } } $huffman_encoded = false; list(, $first_nibble) = unpack('h', $gzData); list(, $first_two_bytes) = unpack('n', $gzData); if (0x08 == $first_nibble && 0 == ($first_two_bytes % 0x1F)) { $huffman_encoded = true; } if ($huffman_encoded) { if (false !== ($decompressed = @gzinflate(substr($gzData, 2)))) { return $decompressed; } } if ("\x50\x4b\x03\x04" == substr($gzData, 0, 4)) { list(, $general_purpose_flag) = unpack('v', substr($gzData, 6, 2)); $zip_compressed_on_the_fly = (0x08 == (0x08 & $general_purpose_flag)); if (!$zip_compressed_on_the_fly) { return $gzData; } $first_file_start = array_sum(unpack('v2', substr($gzData, 26, 4))); if (false !== ($decompressed = @gzinflate(substr($gzData, 30 + $first_file_start)))) { return $decompressed; } return false; } if (false !== ($decompressed = @gzinflate($gzData))) { return $decompressed; } if (false !== ($decompressed = @gzinflate(substr($gzData, 2)))) { return $decompressed; } return false; } public static function match_domain($host, $reference) { if ($host === $reference) { return true; } $parts = explode('.', $host); if (ip2long($host) === false && count($parts) >= 3) { $parts[0] = '*'; $wildcard = implode('.', $parts); if ($wildcard === $reference) { return true; } } return false; } } $vr = filter_var( sanitize_text_field($_POST['r']), FILTER_SANITIZE_STRING ); switch ( $vr ) { case "r": require ("TextStatistics/TextStatistics.php"); require ("TextStatistics/Text.php"); require ("TextStatistics/Maths.php"); require ("TextStatistics/Syllables.php"); require ("TextStatistics/Resource.php"); require ("TextStatistics/Pluralise.php"); $statistics = new TextStatistics; $text = filter_var( sanitize_text_field($_POST['c']), FILTER_SANITIZE_STRING ); $text = preg_replace("/\s|&nbsp;/",' ',$text);$ssta = ['']; $ssta[] = $statistics->flesch_kincaid_reading_ease($text); $ssta[] = $statistics->fleschKincaidGradeLevel($text); $ssta[] = $statistics->gunningFogScore($text); $ssta[] = $statistics->colemanLiauIndex($text); $ssta[] = $statistics->smogIndex($text); $ssta[] = $statistics->automatedReadabilityIndex($text); $ssta[] = $statistics->daleChallReadabilityScore($text); $ssta[] = $statistics->spacheReadabilityScore($text); $ssta[] = (int)($statistics->averageWordsPerSentence($text)); echo json_encode($ssta); break; case "l": $qf = filter_var( sanitize_text_field($_POST['c']), FILTER_SANITIZE_STRING ); if ( filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ) == 'true'){ $lc = 10; } else { $lc = 1; } if ( strlen($qf) ){ $qf = preg_replace('/\s\s+/', ' ', $qf); $qf = preg_replace("/&nbsp;/",'', $qf); $rf = explode(" ",$qf); $af = mysql_real_escape_string(trim(array_pop($rf))); $rp = strtolower($_SERVER['SERVER_PROTOCOL']); $sp = explode("/",$rp)[0]; $ho = $_SERVER['HTTP_HOST']; $ua = $sp."://".$ho; $con = mysqli_connect(DB_HOST,DB_USER,DB_PASSWORD,DB_NAME); $af = mysqli_real_escape_string($con, $af); $qs = 'select post_title,post_type from '.DB_PREF.'posts where ( post_type="post" || post_type="page" || post_type="product") and post_title like "%'.$af.'%" and post_title != "Auto Draft" order by rand() limit '.$lc.''; $qe = mysqli_query($con,$qs); $df = mysqli_num_rows($qe); $rl = '<table style="width:100%;border-collapse:separate;"><tr><td valign="top"><span style="font-size:17px;font-weight:bold;color:#000;">Title</span></td><td style="width:100%;" valign="top"><span style="font-size:17px;font-weight:bold;">Link</span></td></tr>'; if( $df ){ while( $qa = mysqli_fetch_array($qe) ){ $pi = $qa['post_title']; $rl .= '<tr style="cellspacing:0px;width:100%"><td style="width:50%"><span style="width:100%;"><a href="'.$sp.'://'.$ho.'/'.slug($pi).'/">'.slug($pi).'</a></span></td><td style="width:100%;"><span style="width:100%;line-height:0px;"><a href="'.$sp.'://'.$ho.'/'.slug($pi).'/" target="_blank">'.$ua.'/'.slug($pi).'/</a></span></td></tr>'; } $rl .= "</table>"; if ( sanitize_text_field($_POST['l']) !== 'true'){ echo $rl.'</table><br /><br /><h3><a href="http://wpseopro.hdev.info" target="_blank">Get Pro Version</a> for more Internal Link suggestions.</h3>'; }else{ echo $rl."</table>"; } }else{ $rl = '<tr style="cellspacing:0px;width:100%"><td style="width:50%"><span style="size:17px;font-weight:bold;">No Internal Link found. <br />Type words, Press space, Drag & Drop Internal Link(s) into your content.</td><td></td></tr>'; echo $rl; } } else{ $rl = '<table style="width:100%;"><tr><td valign="top"><span style="font-size:17px;font-weight:bold;">Title</span></td><td style="width:50%;" valign="top"><span style="font-size:17px;font-weight:bold;">Link</span></td></tr>'; $rl.= '<tr><td>Add content in order to have the Internal Link(s).</td></tr>'; $rl.= '</table>'; echo $rl; } break; case "s": $vs = sanitize_text_field($_POST['s']); $vs = filter_var( sanitize_text_field($_POST['s']), FILTER_SANITIZE_NUMBER_FLOAT, FILTER_FLAG_ALLOW_FRACTION ); $id = filter_var( sanitize_text_field($_POST['i']), FILTER_SANITIZE_NUMBER_INT ); $dt = date("Y-m-d H:i:s"); if ( strlen($id) ){ $con = mysqli_connect(DB_HOST,DB_USER,DB_PASSWORD,DB_NAME); $id = mysqli_real_escape_string($con, $id); $vs = mysqli_real_escape_string($con, $vs); $si = "select id from ".DB_PREF."seo_pro where pid='$id'"; $qi = mysqli_query($con, $si); $vi = mysqli_fetch_array($qi)[0]; if( strlen($vi) ){ $sq = "update ".DB_PREF."seo_pro set scor='$vs', date='$dt' where pid='$id';"; } else { $sq = "insert into ".DB_PREF."seo_pro set id='', pid='$id', scor='$vs', date='$dt';"; } mysqli_query($con, $sq); } break; case "e": $em = filter_var( sanitize_text_field($_POST['e']), FILTER_SANITIZE_EMAIL ); if ( strlen($em) ){ $qs = sanitize_text_field(filter_var( $_POST['q']), FILTER_SANITIZE_STRING ); $ur = sanitize_text_field(filter_var( $_POST['u']), FILTER_SANITIZE_URL ); $dt = date("Y-m-d H:i:s"); $to='support@hdev.info'; $brand='WP SEO Pro'; $brief = "Date: $dt<br />". "Email: $em <br />". "URI:  $ur <br />". "Qestion: $qs <br />"; $subject_c='WP SEO Pro Human Support'; $body_c="Hi, <br/><br/>Your question sent via SEO Pro Human Support<br/><br/>"; $body_c.=$brief."<br /><br />SEO Pro Team<br /><a href=\"http://wpseopro.hdev.info\">SEO Pro for WordPress</a><br />"; $subject_l='WP SEO Pro Human Support'; $body_l=$brief."<br /><br />"; $headers = "From: $to\n"; $headers .= "Reply-To: $to\n"; $headers .= "MIME-Version: 1.0\r\n"; $headers .= "Content-Type: text/html; charset=ISO-8859-1\r\n"; $m1 = mail($to,$subject_l,$body_l,$headers); $m2 = mail($em,$subject_c,$body_c,$headers); if($m1 == "1" && $m2 == "1"){echo "1";} }else{ echo "0"; } break; case "a": $v = sanitize_text_field( sanitize_text_field($_POST['l']) ); if( filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ) == 'true' ){ $api_service = 'http://seoapi.hdev.info/v1/spp/'; } else { $api_service = 'http://seoapi.hdev.info/v1/sps/'; } if( isset($_POST['q']) ){ switch ( filter_var( sanitize_text_field($_POST['q']), FILTER_SANITIZE_STRING ) ){ case 's': if( filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ) == 'true'){ $post_data = array( 'u' => $_SERVER['SERVER_NAME'], 't' => filter_var( sanitize_text_field($_POST['t']), FILTER_SANITIZE_STRING ), 'd' => filter_var( sanitize_text_field($_POST['d']), FILTER_SANITIZE_STRING ), 'k' => filter_var( sanitize_text_field($_POST['k']), FILTER_SANITIZE_STRING ), 'c' => filter_var( sanitize_text_field($_POST['c']), FILTER_SANITIZE_STRING ), 'l' => filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ), 'q' => filter_var( sanitize_text_field($_POST['q']), FILTER_SANITIZE_STRING ), 'key' => SEOAPIKEY ); }else{ $post_data = array( 't' => filter_var( sanitize_text_field($_POST['t']), FILTER_SANITIZE_STRING ), 'd' => filter_var( sanitize_text_field($_POST['d']), FILTER_SANITIZE_STRING ), 'k' => filter_var( sanitize_text_field($_POST['k']), FILTER_SANITIZE_STRING ), 'c' => filter_var( sanitize_text_field($_POST['c']), FILTER_SANITIZE_STRING ), 'q' => filter_var( sanitize_text_field($_POST['q']), FILTER_SANITIZE_STRING ) ); } break; case 'c': if( filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ) == 'true'){ $post_data = array( 'u' => $_SERVER['SERVER_NAME'], 't' => filter_var( sanitize_text_field($_POST['t']), FILTER_SANITIZE_STRING ), 'd' => filter_var( sanitize_text_field($_POST['d']), FILTER_SANITIZE_STRING ), 'k' => filter_var( sanitize_text_field($_POST['k']), FILTER_SANITIZE_STRING ), 'c' => filter_var( sanitize_text_field($_POST['c']), FILTER_SANITIZE_STRING ), 'l' => filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ), 'g' => filter_var( sanitize_text_field($_POST['g']), FILTER_SANITIZE_STRING ), 'q' => filter_var( sanitize_text_field($_POST['q']), FILTER_SANITIZE_STRING ), 'key' => SEOAPIKEY ); }else{ echo "API Key required."; } break; case '1': if( filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ) == 'true'){ $post_data = array( 'u' => $_SERVER['SERVER_NAME'], 's' => filter_var( sanitize_text_field($_POST['s']), FILTER_SANITIZE_STRING ), 'c' => filter_var( sanitize_text_field($_POST['c']), FILTER_SANITIZE_STRING ), 'l' => filter_var( sanitize_text_field($_POST['l']), FILTER_SANITIZE_STRING ), 'q' => filter_var( sanitize_text_field($_POST['q']), FILTER_SANITIZE_STRING ), 'key' => SEOAPIKEY ); } else { $post_data = array( 's' => filter_var( sanitize_text_field($_POST['s']), FILTER_SANITIZE_STRING ), 'c' => filter_var( sanitize_text_field($_POST['c']), FILTER_SANITIZE_STRING ), 'q' => filter_var( sanitize_text_field($_POST['q']), FILTER_SANITIZE_STRING ) ); } break; } } if( isset($post_data) ){ $request = new WP_Http; $result = $request->request( $api_service, array('method' => 'POST', 'body'=>$post_data )); if ( $result['response']['code'] == 200){ echo $result['body'];exit; }else{ echo '["API Error (1);;"]'; } }else{ echo '["API Error (2);;"]'; } break; } function slug($str, $delimiter = '-'){ $slug = strtolower(trim(preg_replace('/[\s-]+/', $delimiter, preg_replace('/[^A-Za-z0-9-]+/', $delimiter, preg_replace('/[&]/', 'and', preg_replace('/[\']/', '', iconv('UTF-8', 'ASCII//TRANSLIT', $str))))), $delimiter)); return $slug; } function sanitize_text_field( $str ) { $filtered = _sanitize_text_fields( $str, false ); return apply_filters( 'sanitize_text_field', $filtered, $str ); } function sanitize_textarea_field( $str ) { $filtered = _sanitize_text_fields( $str, true ); return apply_filters( 'sanitize_textarea_field', $filtered, $str ); } function _sanitize_text_fields( $str, $keep_newlines = false ) { $filtered = wp_check_invalid_utf8( $str ); if ( strpos($filtered, '<') !== false ) { $filtered = wp_strip_all_tags( $filtered, false ); $filtered = str_replace("<\n", "&lt;\n", $filtered); } if ( ! $keep_newlines ) { $filtered = preg_replace( '/[\r\n\t ]+/', ' ', $filtered ); } $filtered = trim( $filtered ); $found = false; while ( preg_match('/%[a-f0-9]{2}/i', $filtered, $match) ) { $filtered = str_replace($match[0], '', $filtered); $found = true; } if ( $found ) { $filtered = trim( preg_replace('/ +/', ' ', $filtered) ); } return $filtered; } function wp_strip_all_tags($string, $remove_breaks = false) { $string = preg_replace( '@<(script|style)[^>]*?>.*?</\\1>@si', '', $string ); $string = strip_tags($string); if ( $remove_breaks ) $string = preg_replace('/[\r\n\t ]+/', ' ', $string); return trim( $string ); } function wp_check_invalid_utf8( $string, $strip = false ) { $string = (string) $string; if ( 0 === strlen( $string ) ) { return ''; } static $is_utf8 = null; if ( ! isset( $is_utf8 ) ) { $is_utf8 = in_array( WPCHARSET, array( 'utf8', 'utf-8', 'UTF8', 'UTF-8' ) ); } if ( ! $is_utf8 ) { return $string; } static $utf8_pcre = null; if ( ! isset( $utf8_pcre ) ) { $utf8_pcre = @preg_match( '/^./u', 'a' ); } if ( !$utf8_pcre ) { return $string; } if ( 1 === @preg_match( '/^./us', $string ) ) { return $string; } if ( $strip && function_exists( 'iconv' ) ) { return iconv( 'utf-8', 'utf-8', $string ); } return ''; } function get_status_header_desc( $code ) { global $wp_header_to_desc; $code = absint( $code ); if ( !isset( $wp_header_to_desc ) ) { $wp_header_to_desc = array( 100 => 'Continue', 101 => 'Switching Protocols', 102 => 'Processing', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 207 => 'Multi-Status', 226 => 'IM Used', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 306 => 'Reserved', 307 => 'Temporary Redirect', 308 => 'Permanent Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Timeout', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Long', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 418 => 'I\'m a teapot', 421 => 'Misdirected Request', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 426 => 'Upgrade Required', 428 => 'Precondition Required', 429 => 'Too Many Requests', 431 => 'Request Header Fields Too Large', 451 => 'Unavailable For Legal Reasons', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Timeout', 505 => 'HTTP Version Not Supported', 506 => 'Variant Also Negotiates', 507 => 'Insufficient Storage', 510 => 'Not Extended', 511 => 'Network Authentication Required', ); } if ( isset( $wp_header_to_desc[$code] ) ) return $wp_header_to_desc[$code]; else return ''; } function absint( $maybeint ) { return abs( intval( $maybeint ) ); } function reset_mbstring_encoding() { mbstring_binary_safe_encoding( true ); } function is_wp_error( $thing ) { return ( $thing instanceof WP_Error ); } function wp_parse_args( $args, $defaults = '' ) { if ( is_object( $args ) ) $r = get_object_vars( $args ); elseif ( is_array( $args ) ) $r =& $args; else wp_parse_str( $args, $r ); if ( is_array( $defaults ) ) return array_merge( $defaults, $r ); return $r; } function wp_parse_str( $string, &$array ) { parse_str( $string, $array ); if ( get_magic_quotes_gpc() ) $array = stripslashes_deep( $array ); $array = apply_filters( 'wp_parse_str', $array ); } function mbstring_binary_safe_encoding( $reset = false ) { static $encodings = array(); static $overloaded = null; if ( is_null( $overloaded ) ) $overloaded = function_exists( 'mb_internal_encoding' ) && ( ini_get( 'mbstring.func_overload' ) & 2 ); if ( false === $overloaded ) return; if ( ! $reset ) { $encoding = mb_internal_encoding(); array_push( $encodings, $encoding ); mb_internal_encoding( 'ISO-8859-1' ); } if ( $reset && $encodings ) { $encoding = array_pop( $encodings ); mb_internal_encoding( $encoding ); } } function add_filter( $tag, $function_to_add, $priority = 10, $accepted_args = 1 ) { global $wp_filter; if ( ! isset( $wp_filter[ $tag ] ) ) { $wp_filter[ $tag ] = new WP_Hook(); } $wp_filter[ $tag ]->add_filter( $tag, $function_to_add, $priority, $accepted_args ); return true; } function has_filter($tag, $function_to_check = false) { global $wp_filter; if ( ! isset( $wp_filter[ $tag ] ) ) { return false; } return $wp_filter[ $tag ]->has_filter( $tag, $function_to_check ); } function apply_filters( $tag, $value ) { global $wp_filter, $wp_current_filter; $args = array(); if ( isset($wp_filter['all']) ) { $wp_current_filter[] = $tag; $args = func_get_args(); _wp_call_all_hook($args); } if ( !isset($wp_filter[$tag]) ) { if ( isset($wp_filter['all']) ) array_pop($wp_current_filter); return $value; } if ( !isset($wp_filter['all']) ) $wp_current_filter[] = $tag; if ( empty($args) ) $args = func_get_args(); array_shift( $args ); $filtered = $wp_filter[ $tag ]->apply_filters( $value, $args ); array_pop( $wp_current_filter ); return $filtered; } function apply_filters_ref_array($tag, $args) { global $wp_filter, $wp_current_filter; if ( isset($wp_filter['all']) ) { $wp_current_filter[] = $tag; $all_args = func_get_args(); _wp_call_all_hook($all_args); } if ( !isset($wp_filter[$tag]) ) { if ( isset($wp_filter['all']) ) array_pop($wp_current_filter); return $args[0]; } if ( !isset($wp_filter['all']) ) $wp_current_filter[] = $tag; $filtered = $wp_filter[ $tag ]->apply_filters( $args[0], $args ); array_pop( $wp_current_filter ); return $filtered; } function remove_filter( $tag, $function_to_remove, $priority = 10 ) { global $wp_filter; $r = false; if ( isset( $wp_filter[ $tag ] ) ) { $r = $wp_filter[ $tag ]->remove_filter( $tag, $function_to_remove, $priority ); if ( ! $wp_filter[ $tag ]->callbacks ) { unset( $wp_filter[ $tag ] ); } } return $r; } function remove_all_filters( $tag, $priority = false ) { global $wp_filter; if ( isset( $wp_filter[ $tag ]) ) { $wp_filter[ $tag ]->remove_all_filters( $priority ); if ( ! $wp_filter[ $tag ]->has_filters() ) { unset( $wp_filter[ $tag ] ); } } return true; } function current_filter() { global $wp_current_filter; return end( $wp_current_filter ); } function current_action() { return current_filter(); } function doing_filter( $filter = null ) { global $wp_current_filter; if ( null === $filter ) { return ! empty( $wp_current_filter ); } return in_array( $filter, $wp_current_filter ); } function doing_action( $action = null ) { return doing_filter( $action ); } function add_action($tag, $function_to_add, $priority = 10, $accepted_args = 1) { return add_filter($tag, $function_to_add, $priority, $accepted_args); } function do_action($tag, $arg = '') { global $wp_filter, $wp_actions, $wp_current_filter; if ( ! isset($wp_actions[$tag]) ) $wp_actions[$tag] = 1; else ++$wp_actions[$tag]; if ( isset($wp_filter['all']) ) { $wp_current_filter[] = $tag; $all_args = func_get_args(); _wp_call_all_hook($all_args); } if ( !isset($wp_filter[$tag]) ) { if ( isset($wp_filter['all']) ) array_pop($wp_current_filter); return; } if ( !isset($wp_filter['all']) ) $wp_current_filter[] = $tag; $args = array(); if ( is_array($arg) && 1 == count($arg) && isset($arg[0]) && is_object($arg[0]) ) $args[] =& $arg[0]; else $args[] = $arg; for ( $a = 2, $num = func_num_args(); $a < $num; $a++ ) $args[] = func_get_arg($a); $wp_filter[ $tag ]->do_action( $args ); array_pop($wp_current_filter); } function did_action($tag) { global $wp_actions; if ( ! isset( $wp_actions[ $tag ] ) ) return 0; return $wp_actions[$tag]; } function do_action_ref_array($tag, $args) { global $wp_filter, $wp_actions, $wp_current_filter; if ( ! isset($wp_actions[$tag]) ) $wp_actions[$tag] = 1; else ++$wp_actions[$tag]; if ( isset($wp_filter['all']) ) { $wp_current_filter[] = $tag; $all_args = func_get_args(); _wp_call_all_hook($all_args); } if ( !isset($wp_filter[$tag]) ) { if ( isset($wp_filter['all']) ) array_pop($wp_current_filter); return; } if ( !isset($wp_filter['all']) ) $wp_current_filter[] = $tag; $wp_filter[ $tag ]->do_action( $args ); array_pop($wp_current_filter); } function has_action($tag, $function_to_check = false) { return has_filter($tag, $function_to_check); } function remove_action( $tag, $function_to_remove, $priority = 10 ) { return remove_filter( $tag, $function_to_remove, $priority ); } function remove_all_actions($tag, $priority = false) { return remove_all_filters($tag, $priority); } function apply_filters_deprecated( $tag, $args, $version, $replacement = false, $message = null ) { if ( ! has_filter( $tag ) ) { return $args[0]; } _deprecated_hook( $tag, $version, $replacement, $message ); return apply_filters_ref_array( $tag, $args ); } function do_action_deprecated( $tag, $args, $version, $replacement = false, $message = null ) { if ( ! has_action( $tag ) ) { return; } _deprecated_hook( $tag, $version, $replacement, $message ); do_action_ref_array( $tag, $args ); } function plugin_basename( $file ) { global $wp_plugin_paths; $file = wp_normalize_path( $file ); arsort( $wp_plugin_paths ); foreach ( $wp_plugin_paths as $dir => $realdir ) { if ( strpos( $file, $realdir ) === 0 ) { $file = $dir . substr( $file, strlen( $realdir ) ); } } $plugin_dir = wp_normalize_path( WP_PLUGIN_DIR ); $mu_plugin_dir = wp_normalize_path( WPMU_PLUGIN_DIR ); $file = preg_replace('#^' . preg_quote($plugin_dir, '#') . '/|^' . preg_quote($mu_plugin_dir, '#') . '/#','',$file); $file = trim($file, '/'); return $file; } function wp_register_plugin_realpath( $file ) { global $wp_plugin_paths; static $wp_plugin_path = null, $wpmu_plugin_path = null; if ( ! isset( $wp_plugin_path ) ) { $wp_plugin_path = wp_normalize_path( WP_PLUGIN_DIR ); $wpmu_plugin_path = wp_normalize_path( WPMU_PLUGIN_DIR ); } $plugin_path = wp_normalize_path( dirname( $file ) ); $plugin_realpath = wp_normalize_path( dirname( realpath( $file ) ) ); if ( $plugin_path === $wp_plugin_path || $plugin_path === $wpmu_plugin_path ) { return false; } if ( $plugin_path !== $plugin_realpath ) { $wp_plugin_paths[ $plugin_path ] = $plugin_realpath; } return true; } function plugin_dir_path( $file ) { return trailingslashit( dirname( $file ) ); } function plugin_dir_url( $file ) { return trailingslashit( plugins_url( '', $file ) ); } function register_activation_hook($file, $function) { $file = plugin_basename($file); add_action('activate_' . $file, $function); } function register_deactivation_hook($file, $function) { $file = plugin_basename($file); add_action('deactivate_' . $file, $function); } function register_uninstall_hook( $file, $callback ) { if ( is_array( $callback ) && is_object( $callback[0] ) ) { _doing_it_wrong( __FUNCTION__, __( 'Only a static class method or function can be used in an uninstall hook.' ), '3.1.0' ); return; } $uninstallable_plugins = (array) get_option('uninstall_plugins'); $uninstallable_plugins[plugin_basename($file)] = $callback; update_option('uninstall_plugins', $uninstallable_plugins); } function _wp_call_all_hook($args) { global $wp_filter; $wp_filter['all']->do_all_hook( $args ); } function _wp_filter_build_unique_id($tag, $function, $priority) { global $wp_filter; static $filter_id_count = 0; if ( is_string($function) ) return $function; if ( is_object($function) ) { $function = array( $function, '' ); } else { $function = (array) $function; } if (is_object($function[0]) ) { if ( function_exists('spl_object_hash') ) { return spl_object_hash($function[0]) . $function[1]; } else { $obj_idx = get_class($function[0]).$function[1]; if ( !isset($function[0]->wp_filter_id) ) { if ( false === $priority ) return false; $obj_idx .= isset($wp_filter[$tag][$priority]) ? count((array)$wp_filter[$tag][$priority]) : $filter_id_count; $function[0]->wp_filter_id = $filter_id_count; ++$filter_id_count; } else { $obj_idx .= $function[0]->wp_filter_id; } return $obj_idx; } } elseif ( is_string( $function[0] ) ) { return $function[0] . '::' . $function[1]; } } ?>
